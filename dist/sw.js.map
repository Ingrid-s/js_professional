{"version":3,"sources":["sw.js"],"names":["VERSION","self","addEventListener","event","waitUntil","precache","request","method","respondWith","cachedResponse","updateCache","cache","caches","open","addAll","response","match","fetch","put"],"mappings":"AAAA,MAAMA,OAAO,GAAG,IAAhB;AAEAC,IAAI,CAACC,gBAAL,CAAsB,SAAtB,EAAiCC,KAAK,IAAI;AACtCA,EAAAA,KAAK,CAACC,SAAN,CAAgBC,QAAQ,EAAxB;AACD,CAFH;AAIAJ,IAAI,CAACC,gBAAL,CAAsB,OAAtB,EAA+BC,KAAK,IAAI;AACpC,QAAMG,OAAO,GAAGH,KAAK,CAACG,OAAtB,CADoC,CAEpC;;AACA,MAAIA,OAAO,CAACC,MAAR,KAAmB,KAAvB,EAA8B;AAC1B;AACH,GALmC,CAOpC;;;AACAJ,EAAAA,KAAK,CAACK,WAAN,CAAkBC,cAAc,CAACH,OAAD,CAAhC,EARoC,CAUpC;;AACAH,EAAAA,KAAK,CAACC,SAAN,CAAgBM,WAAW,CAACJ,OAAD,CAA3B;AACH,CAZD;;AAcA,eAAeD,QAAf,GAA0B;AACtB,QAAMM,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,OAAZ,CAApB;AACA,SAAOW,KAAK,CAACG,MAAN,CAAa,CAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARkB,GAAb,CAAP;AAUD;;AAEH,eAAeL,cAAf,CAA8BH,OAA9B,EAAuC;AACnC;AACA,QAAMK,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,OAAZ,CAApB,CAFmC,CAGnC;;AACA,QAAMe,QAAQ,GAAG,MAAMJ,KAAK,CAACK,KAAN,CAAYV,OAAZ,CAAvB,CAJmC,CAKnC;;AACA,SAAOS,QAAQ,IAAIE,KAAK,CAACX,OAAD,CAAxB;AACH;;AAED,eAAeI,WAAf,CAA2BJ,OAA3B,EAAoC;AAChC,QAAMK,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,OAAZ,CAApB;AACA,QAAMe,QAAQ,GAAG,MAAME,KAAK,CAACX,OAAD,CAA5B,CAFgC,CAGhC;;AACA,SAAOK,KAAK,CAACO,GAAN,CAAUZ,OAAV,EAAmBS,QAAnB,CAAP;AACH","file":"sw.js","sourceRoot":"..","sourcesContent":["const VERSION = 'v1';\n\nself.addEventListener('install', event => {\n    event.waitUntil(precache());\n  });\n\nself.addEventListener('fetch', event => {\n    const request = event.request;\n    // aquí el único método que nos interesa es el get\n    if (request.method !== 'GET') {\n        return;\n    }\n\n    //Buscar en el cache, para ver si ya tenemos los datos de esta petición.\n    event.respondWith(cachedResponse(request));\n\n    //para actualizar el cache y asegurar que tenemos la versión más reciente de los archivos:\n    event.waitUntil(updateCache(request));\n});\n\nasync function precache() {\n    const cache = await caches.open(VERSION);\n    return cache.addAll([\n      // '/',\n      // '/index.html',\n      // '/assets/index.js',\n      // '/assets/MediaPlayer.js',\n      // '/assets/plugins/AutoPlay.js',\n      // '/assets/plugins/AutoPause.ts',\n      // '/assets/index.css',\n      // '/assets/BigBuckBunny.mp4',\n    ]);\n  }\n\nasync function cachedResponse(request) {\n    //abrimos la versión específica que hemos declarado en VERSION, que en este caso es la v1\n    const cache = await caches.open(VERSION);\n    //aquí le preguntamos al cache si ya tiene la petición que querenoos hacer:\n    const response = await cache.match(request);\n    // aquí es importante agregar el || fetch(request), porque si no se tiene en cache, regresaría undefined y nunca ejecutaria la petición\n    return response || fetch(request);\n}\n\nasync function updateCache(request) {\n    const cache = await caches.open(VERSION);\n    const response = await fetch(request);\n    //llamamos a networtk para actualizar el cache\n    return cache.put(request, response);\n}"]}